[#future_work]
= Future Work

:idprefix: future_work_

A number of features asked by reviewers and users of Boost.Bloom are
considered for inclusion into future versions of the library. 

== Bulk operations

Each insertion/lookup operation for `boost::bloom::filter` likely involves one or more
cache misses in the access to the internal bit array. Following a similar
approach to that of
https://bannalia.blogspot.com/2023/10/bulk-visitation-in-boostconcurrentflatm.html[bulk visitation^]
in Boost.Unordered, we can pipeline several operations so that
cache miss stalls are leveraged to do useful computation. The interface
for this functionality could be as follows:

[listing,subs="+macros,+quotes"]
-----
f.insert(first1, last1);
f.may_contain(first2, last2, [] (const value_type& x, bool res) {
  // x is (likely) in the filter if res == true
});
-----

== `try_insert`

To avoid inserting an already present element, we now have to do:

[listing,subs="+macros,+quotes"]
-----
if(!f.may_contain(x)) f.insert(x);
-----

These two calls can be combined in a potentially faster,
single operation:

[listing,subs="+macros,+quotes"]
-----
bool res = f.try_insert(x); // returns true if x was not present
-----

== Estimation of number of elements inserted

For a classical Bloom filter, the number of elements actually inserted
can be estimated from the number {small}stem:[B]{small-end} of bits set
to one in the array as

[.text-center]
{small}stem:[n\approx-\displaystyle\frac{m}{k}\ln\left(1-\displaystyle\frac{B}{m}\right),]{small-end}

which can be used for the implementation of a member function
`estimated_size`. As of this writing, we don't know how to extend the
formula to the case of block and multiblock filters. Any help on this
problem is much appreciated.
